// @bun
import l from"fs/promises";import{open as C}from"fs/promises";var W=(R)=>{const v=R.split("\r\n"),K=v[0],G=/^HTTP\/(\d+\.\d+)\s+(\d+)\s+(.*)$/,F=K.match(G),A=F?{http:F[1],status:parseInt(F[2],10),message:F[3].trim()}:{};return{...v.slice(1).filter((V)=>V.trim()!=="").reduce((V,J)=>{const Z=J.indexOf(":");if(Z!==-1){const X=J.slice(0,Z).trim().toLowerCase(),q=J.slice(Z+1).trim();return{...V,[X]:q}}return V},{}),...A}};var L=(R,v)=>{const K=v?.skipContent||!1,G=v?.readBufferSize||512n+256n;let F="",A=0n,I=!1;return{[Symbol.asyncIterator](){return{async next(){if(I)return{done:!0,value:void 0};let V=void 0,J,Z,X={recordWarcOffset:0n,recordResponseOffset:0n,recordContentOffset:0n};try{do{let q=F,D=[];X.recordWarcOffset=A-BigInt(q.length);while(D.length<2){const Q=q.split("\r\n\r\n");if(D=Q.length>1?Q:D,D.length<2){const Y=await R(A,G);q+=Y.toString(),A+=G}}J=W(D[0]);const _=J["content-length"]?BigInt(J["content-length"]):0n;if(J["warc-type"]!=="response"||_===0n){const Q=_-BigInt(q.length-D[0].length-4);A+=Q>0n?Q:0n,F=Q<0n?q.slice(q.length+Number(Q)+4):""}else{while(D.length<3){const E=q.split("\r\n\r\n");if(D=E.length>2?E:D,D.length<3){const N=await R(A,G);q+=N.toString(),A+=G}}Z=W(D[1]);const Q=_-BigInt(D[1].length),Y=Q-BigInt(q.length-D[0].length-D[1].length-8);V=K?void 0:Buffer.from(q.slice(D[0].length+D[1].length+8,D[0].length+D[1].length+8+Number(Q))+(Y>0n?(await R(A,Y)).toString():"")),A+=Y>0n?Y:0n,F=Y<0n?q.slice(q.length+Number(Y)+4):"",X.recordResponseOffset=X.recordWarcOffset+BigInt(D[0].length+4),X.recordContentOffset=X.recordResponseOffset+BigInt(D[1].length+4),Z["content-length"]=Q}}while(J&&J["warc-type"]!=="response");if(!J)return I=!0,{done:!0,value:void 0};return{done:!1,value:[J,Z,V,X]}}catch(q){if(q instanceof RangeError)return I=!0,{done:!0,value:void 0};else throw q}}}}}};var U=null,M=new Map,O=async()=>{if(!U){const R=await Bun.build({entrypoints:["libs/database/worker.tsx"],outdir:"libs/database/build",target:"bun",minify:!0});U=new Worker(R.outputs[0].path),U.onmessage=(v)=>{const{id:K,status:G,data:F,message:A}=v.data,I=M.get(K);if(I){if(G==="error")I.reject(A);else I.resolve(F);M.delete(K)}}}return{worker:U,promises:M}};var{worker:g,promises:m}=await O(),p=(R,v)=>{return new Promise((K,G)=>{const F=process.hrtime()[1];m.set(F,{resolve:K,reject:G}),g.postMessage({id:F,action:R,params:v})})};var w=async()=>p("closeDb"),H=async(R)=>p("dbInsertResponse",R);var z=(R)=>{if(typeof R==="bigint"){if(R>Number.MAX_SAFE_INTEGER||R<Number.MIN_SAFE_INTEGER)throw new Error("BigInt value out of safe Number range");return Number(R)}else if(typeof R==="object"&&R!==null){for(let v in R)if(R.hasOwnProperty(v))R[v]=z(R[v])}return R},d=async(R)=>{const v=await C(R,"r"),G=(await v.stat()).size;return async(F,A)=>{if(F>=G||F+A>G)throw new RangeError("Out of bounds read attempt");const I=Buffer.alloc(Number(A)),{bytesRead:V}=await v.read(I,0,Number(A),Number(F));if(V!==Number(A))throw new Error("Failed to read the expected number of bytes");return I}},b=async(R)=>{const v=L(await d(`warcs/${R}`),{skipContent:!0}),K=[];console.log(`   Parsing ${R}...`);const G=(await l.stat(`warcs/${R}`)).size;let F=0;for await(let[A,I,V,J]of v){const{"warc-type":Z,"warc-record-id":X,"warc-warcinfo-id":q,"warc-concurrent-to":D,"warc-target-uri":_,"warc-date":Q,"warc-ip-address":Y,"warc-block-digest":E,"warc-payload-digest":N,"content-type":k,"content-length":c}=A,{date:s,location:o,"content-type":x,"content-length":j,"last-modified":u,"transfer-encoding":i,status:P}=I,{recordWarcOffset:S,recordResponseOffset:T,recordContentOffset:B}=J,y={uri_string:_.replace(/<|>/g,""),file_string:`warcs/${R}`,content_type_string:x??"application/unknown",resource_type_string:"response",record_length:BigInt(T),record_offset:BigInt(S),content_length:BigInt(j),content_offset:BigInt(B),status:P,meta:z(I)};try{K.push(H(y).then(async()=>{const $=Math.round(Number(S)/G*100);if($>F)F=$,postMessage({file:R,status:"progress",progress:$})}))}catch($){console.log(`Failed to insert record ${$.message}`,y)}}Promise.allSettled(K).then(()=>{console.log(`   Parsed ${R}!`),w().then(()=>{postMessage({file:R,status:"complete"})})})};self.onmessage=(R)=>{console.log("entry");const v=R.data;if(typeof v!=="object"||!("file"in v)){console.log(`WARC Worker, invalid format ${v}`);return}console.log(`WARC Worker: starting to parse file: ${v.file}`),b(v.file)};
