import d from"fs/promises";import{open as b}from"fs/promises";var p=(R)=>{const v=R.split("\r\n"),K=v[0],G=/^HTTP\/(\d+\.\d+)\s+(\d+)\s+(.*)$/,F=K.match(G),A=F?{http:F[1],status:parseInt(F[2],10),message:F[3].trim()}:{};return{...v.slice(1).filter((V)=>V.trim()!=="").reduce((V,J)=>{const Z=J.indexOf(":");if(Z!==-1){const X=J.slice(0,Z).trim().toLowerCase(),q=J.slice(Z+1).trim();return{...V,[X]:q}}return V},{}),...A}};var O=(R,v)=>{const K=v?.skipContent||!1,G=v?.readBufferSize||512n+256n;let F="",A=0n,I=!1;return{[Symbol.asyncIterator](){return{async next(){if(I)return{done:!0,value:void 0};let V=void 0,J,Z,X={recordWarcOffset:0n,recordResponseOffset:0n,recordContentOffset:0n};try{do{let q=F,D=[];X.recordWarcOffset=A-BigInt(q.length);while(D.length<2){const Q=q.split("\r\n\r\n");if(D=Q.length>1?Q:D,D.length<2){const Y=await R(A,G);q+=Y.toString(),A+=G}}J=p(D[0]);const _=J["content-length"]?BigInt(J["content-length"]):0n;if(J["warc-type"]!=="response"||_===0n){const Q=_-BigInt(q.length-D[0].length-4);A+=Q>0n?Q:0n,F=Q<0n?q.slice(q.length+Number(Q)+4):""}else{while(D.length<3){const E=q.split("\r\n\r\n");if(D=E.length>2?E:D,D.length<3){const S=await R(A,G);q+=S.toString(),A+=G}}Z=p(D[1]);const Q=_-BigInt(D[1].length),Y=Q-BigInt(q.length-D[0].length-D[1].length-8);V=K?void 0:Buffer.from(q.slice(D[0].length+D[1].length+8,D[0].length+D[1].length+8+Number(Q))+(Y>0n?(await R(A,Y)).toString():"")),A+=Y>0n?Y:0n,F=Y<0n?q.slice(q.length+Number(Y)+4):"",X.recordResponseOffset=X.recordWarcOffset+BigInt(D[0].length+4),X.recordContentOffset=X.recordResponseOffset+BigInt(D[1].length+4),Z["content-length"]=Q}}while(J&&J["warc-type"]!=="response");if(!J)return I=!0,{done:!0,value:void 0};return{done:!1,value:[J,Z,V,X]}}catch(q){if(q instanceof RangeError)return I=!0,{done:!0,value:void 0};else throw q}}}}}};var U=null,M=new MessageChannel,N=new Map,w=async()=>{if(!U){const R=await Bun.build({entrypoints:["libs/database/worker.tsx"],outdir:"libs/database/build",target:process.env.WORKER_TARGET??"node",minify:!0});U=new Worker(R.outputs[0].path),U.onmessage=(v)=>{const{id:K,status:G,data:F,message:A}=v.data,I=N.get(K);if(I){if(G==="error")I.reject(A);else I.resolve(F);N.delete(K)}}}if(!M)M=new MessageChannel;return{worker:U,channel:M,promises:N}};var{worker:H,promises:z}=await w(),y=(R,v)=>{return new Promise((K,G)=>{const F=process.hrtime()[1];z.set(F,{resolve:K,reject:G}),H.postMessage({id:F,action:R,params:v})})},x=async(R)=>y("connectDb",R);var P=async(R)=>y("dbInsertResponse",R);var j=async()=>{await y("closeDb"),H.terminate(),z.clear()};var T=(R)=>{if(typeof R==="bigint"){if(R>Number.MAX_SAFE_INTEGER||R<Number.MIN_SAFE_INTEGER)throw new Error("BigInt value out of safe Number range");return Number(R)}else if(typeof R==="object"&&R!==null){for(let v in R)if(R.hasOwnProperty(v))R[v]=T(R[v])}return R},k=async(R)=>{const v=await b(R,"r"),G=(await v.stat()).size;return async(F,A)=>{if(F>=G||F+A>G)throw new RangeError("Out of bounds read attempt");const I=Buffer.alloc(Number(A)),{bytesRead:V}=await v.read(I,0,Number(A),Number(F));if(V!==Number(A))throw new Error("Failed to read the expected number of bytes");return I}},c=async(R)=>{const v=O(await k(`warcs/${R}`),{skipContent:!0}),K=[];console.log(`   Parsing ${R}...`);const G=(await d.stat(`warcs/${R}`)).size;let F=0;for await(let[A,I,V,J]of v){const{"warc-type":Z,"warc-record-id":X,"warc-warcinfo-id":q,"warc-concurrent-to":D,"warc-target-uri":_,"warc-date":Q,"warc-ip-address":Y,"warc-block-digest":E,"warc-payload-digest":S,"content-type":o,"content-length":s}=A,{date:i,location:u,"content-type":B,"content-length":g,"last-modified":a,"transfer-encoding":h,status:m}=I,{recordWarcOffset:W,recordResponseOffset:l,recordContentOffset:C}=J,L={uri_string:_.replace(/<|>/g,""),file_string:`warcs/${R}`,content_type_string:B??"application/unknown",resource_type_string:"response",record_length:BigInt(l),record_offset:BigInt(W),content_length:BigInt(g),content_offset:BigInt(C),status:m,meta:T(I)};try{K.push(P(L).then(async()=>{const $=Math.round(Number(W)/G*100);if($>F)F=$,postMessage({file:R,status:"progress",progress:$})}))}catch($){console.log(`Failed to insert record ${$.message}`,L)}}Promise.allSettled(K).then(()=>{console.log(`   Parsed ${R}!`),j().then(()=>{postMessage({file:R,status:"complete"})})})};self.onmessage=(R)=>{console.log("entry");const v=R.data;if(typeof v!=="object"||!("file"in v)){console.log(`WARC Worker, invalid format ${v}`);return}console.log(`WARC Worker: starting to parse file: ${v.file}`),x({max:4}).then(()=>{c(v.file)})};
